<?xml version="1.0" encoding="Windows-1252" ?>
<!DOCTYPE api SYSTEM "CompletionXml.dtd">
<api language="python">
	<environment paramStartChar="(" paramEndChar=")"
		paramSeparator=", " terminal=";" />
	<keywords>
		<keyword name="ArithmeticError" type="function" returnType=""
			definedIn="built-in">
			<desc><![CDATA[Base class for arithmetic errors.]]></desc>
		</keyword>
		<keyword name="AssertionError" type="function" returnType="">
			<desc><![CDATA[Assertion failed.]]></desc>
		</keyword>
		<keyword name="AttributeError" type="function" returnType="">
			<desc><![CDATA[Attribute not found.]]></desc>
		</keyword>
		<keyword name="BaseException" type="function" returnType="">
			<desc><![CDATA[Common base class for all exceptions]]></desc>
		</keyword>
		<keyword name="BufferError" type="function" returnType="">
			<desc><![CDATA[Buffer error.]]></desc>
		</keyword>
		<keyword name="BytesWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about bytes and buffer related problems, mostly&#x0a;related to conversion from str or comparing to str.]]></desc>
		</keyword>
		<keyword name="DeprecationWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about deprecated features.]]></desc>
		</keyword>
		<keyword name="EOFError" type="function" returnType="">
			<desc><![CDATA[Read beyond end of file.]]></desc>
		</keyword>
		<keyword name="EnvironmentError" type="function" returnType="">
			<desc><![CDATA[Base class for I/O related errors.]]></desc>
		</keyword>
		<keyword name="Exception" type="function" returnType="">
			<desc><![CDATA[Common base class for all non-exit exceptions.]]></desc>
		</keyword>
		<keyword name="False" type="other" definedIn="built-in" />
		<keyword name="FloatingPointError" type="function" returnType="">
			<desc><![CDATA[Floating point operation failed.]]></desc>
		</keyword>
		<keyword name="FutureWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about constructs that will change semantically&#x0a;in the future.]]></desc>
		</keyword>
		<keyword name="GeneratorExit" type="function" returnType="">
			<desc><![CDATA[Request that a generator exit.]]></desc>
		</keyword>
		<keyword name="IOError" type="function" returnType="">
			<desc><![CDATA[I/O operation failed.]]></desc>
		</keyword>
		<keyword name="ImportError" type="function" returnType="">
			<desc><![CDATA[Import can't find module, or can't find name in module.]]></desc>
		</keyword>
		<keyword name="ImportWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about probable mistakes in module imports]]></desc>
		</keyword>
		<keyword name="IndentationError" type="function" returnType="">
			<desc><![CDATA[Improper indentation.]]></desc>
		</keyword>
		<keyword name="IndexError" type="function" returnType="">
			<desc><![CDATA[Sequence index out of range.]]></desc>
		</keyword>
		<keyword name="KeyError" type="function" returnType="">
			<desc><![CDATA[Mapping key not found.]]></desc>
		</keyword>
		<keyword name="KeyboardInterrupt" type="function" returnType="">
			<desc><![CDATA[Program interrupted by user.]]></desc>
		</keyword>
		<keyword name="LookupError" type="function" returnType="">
			<desc><![CDATA[Base class for lookup errors.]]></desc>
		</keyword>
		<keyword name="MemoryError" type="function" returnType="">
			<desc><![CDATA[Out of memory.]]></desc>
		</keyword>
		<keyword name="NameError" type="function" returnType="">
			<desc><![CDATA[Name not found globally.]]></desc>
		</keyword>
		<keyword name="None" type="other" definedIn="built-in" />
		<keyword name="NotImplementedError" type="function"
			returnType="">
			<desc><![CDATA[Method or function hasn't been implemented yet.]]></desc>
		</keyword>
		<keyword name="OSError" type="function" returnType="">
			<desc><![CDATA[OS system call failed.]]></desc>
		</keyword>
		<keyword name="OverflowError" type="function" returnType="">
			<desc><![CDATA[Result too large to be represented.]]></desc>
		</keyword>
		<keyword name="PendingDeprecationWarning" type="function"
			returnType="">
			<desc><![CDATA[Base class for warnings about features which will be deprecated&#x0a;in the future.]]></desc>
		</keyword>
		<keyword name="ReferenceError" type="function" returnType="">
			<desc><![CDATA[Weak ref proxy used after referent went away.]]></desc>
		</keyword>
		<keyword name="RuntimeError" type="function" returnType="">
			<desc><![CDATA[Unspecified run-time error.]]></desc>
		</keyword>
		<keyword name="RuntimeWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about dubious runtime behavior.]]></desc>
		</keyword>
		<keyword name="StandardError" type="function" returnType="">
			<desc><![CDATA[Base class for all standard Python exceptions that do not represent&#x0a;interpreter exiting.]]></desc>
		</keyword>
		<keyword name="StopIteration" type="function" returnType="">
			<desc><![CDATA[Signal the end from iterator.next().]]></desc>
		</keyword>
		<keyword name="SyntaxError" type="function" returnType="">
			<desc><![CDATA[Invalid syntax.]]></desc>
		</keyword>
		<keyword name="SyntaxWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about dubious syntax.]]></desc>
		</keyword>
		<keyword name="SystemError" type="function" returnType="">
			<desc><![CDATA[Internal error in the Python interpreter.&#x0a;&#x0a;Please report this to the Python maintainer, along with the traceback,&#x0a;the Python version, and the hardware/OS platform and version.]]></desc>
		</keyword>
		<keyword name="SystemExit" type="function" returnType="">
			<desc><![CDATA[Request to exit from the interpreter.]]></desc>
		</keyword>
		<keyword name="TabError" type="function" returnType="">
			<desc><![CDATA[Improper mixture of spaces and tabs.]]></desc>
		</keyword>
		<keyword name="True" type="other" definedIn="built-in" />
		<keyword name="TypeError" type="function" returnType="">
			<desc><![CDATA[Inappropriate argument type.]]></desc>
		</keyword>
		<keyword name="UnboundLocalError" type="function" returnType="">
			<desc><![CDATA[Local name referenced but not bound to a value.]]></desc>
		</keyword>
		<keyword name="UnicodeDecodeError" type="function" returnType="">
			<desc><![CDATA[Unicode decoding error.]]></desc>
		</keyword>
		<keyword name="UnicodeEncodeError" type="function" returnType="">
			<desc><![CDATA[Unicode encoding error.]]></desc>
		</keyword>
		<keyword name="UnicodeError" type="function" returnType="">
			<desc><![CDATA[Unicode related error.]]></desc>
		</keyword>
		<keyword name="UnicodeTranslateError" type="function"
			returnType="">
			<desc><![CDATA[Unicode translation error.]]></desc>
		</keyword>
		<keyword name="UnicodeWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings about Unicode related problems, mostly&#x0a;related to conversion problems.]]></desc>
		</keyword>
		<keyword name="UserWarning" type="function" returnType="">
			<desc><![CDATA[Base class for warnings generated by user code.]]></desc>
		</keyword>
		<keyword name="ValueError" type="function" returnType="">
			<desc><![CDATA[Inappropriate argument value (of correct type).]]></desc>
		</keyword>
		<keyword name="Warning" type="function" returnType="">
			<desc><![CDATA[Base class for warning categories.]]></desc>
		</keyword>
		<keyword name="ZeroDivisionError" type="function" returnType="">
			<desc><![CDATA[Second argument to a division or modulo operation was zero.]]></desc>
		</keyword>
		<keyword name="abs" type="function" returnType="">
			<desc><![CDATA[abs(number) -&gt; number&#x0a;&#x0a;Return the absolute value of the argument.]]></desc>
		</keyword>
		<keyword name="add" type="function" returnType="">
			<desc><![CDATA[Add an element to a set.&#x0a;&#x0a;This has no effect if the element is already present.]]></desc>
		</keyword>
		<keyword name="all" type="function" returnType="">
			<desc><![CDATA[all(iterable) -&gt; bool&#x0a;&#x0a;Return True if bool(x) is True for all values x in the iterable.]]></desc>
		</keyword>
		<keyword name="and" type="other" definedIn="built-in" />
		<keyword name="any" type="function" returnType="">
			<desc><![CDATA[any(iterable) -&gt; bool&#x0a;&#x0a;Return True if bool(x) is True for any x in the iterable.]]></desc>
		</keyword>
		<keyword name="append" type="function" returnType="">
			<desc><![CDATA[B.append(int) -&gt; None&#x0a;&#x0a;Append a single item to the end of B.]]></desc>
		</keyword>
		<keyword name="apply" type="function" returnType="">
			<desc><![CDATA[apply(object[, args[, kwargs]]) -&gt; value&#x0a;&#x0a;Call a callable object with positional arguments taken from the tuple args,&#x0a;and keyword arguments taken from the optional dictionary kwargs.&#x0a;Note that classes are callable, as are instances with a __call__() method.&#x0a;&#x0a;Deprecated since release 2.3. Instead, use the extended call syntax:&#x0a;    function(*args, **keywords).]]></desc>
		</keyword>
		<keyword name="as" type="other" definedIn="built-in" />
		<keyword name="as_integer_ratio" type="function" returnType="">
			<desc><![CDATA[float.as_integer_ratio() -&gt; (int, int)&#x0a;&#x0a;Returns a pair of integers, whose ratio is exactly equal to the original&#x0a;float and with a positive denominator.&#x0a;Raises OverflowError on infinities and a ValueError on NaNs.&#x0a;&#x0a;&gt;&gt;&gt; (10.0).as_integer_ratio()&#x0a;(10, 1)&#x0a;&gt;&gt;&gt; (0.0).as_integer_ratio()&#x0a;(0, 1)&#x0a;&gt;&gt;&gt; (-.25).as_integer_ratio()&#x0a;(-1, 4)]]></desc>
		</keyword>
		<keyword name="assert" type="other" definedIn="built-in" />
		<keyword name="basestring" type="function" returnType="">
			<desc><![CDATA[Type basestring cannot be instantiated; it is the base for str and unicode.]]></desc>
		</keyword>
		<keyword name="bin" type="function" returnType="">
			<desc><![CDATA[bin(number) -&gt; string&#x0a;&#x0a;Return the binary representation of an integer or long integer.]]></desc>
		</keyword>
		<keyword name="bit_length" type="function" returnType="">
			<desc><![CDATA[long.bit_length() -&gt; int or long&#x0a;&#x0a;Number of bits necessary to represent self in binary.&#x0a;&gt;&gt;&gt; bin(37L)&#x0a;'0b100101'&#x0a;&gt;&gt;&gt; (37L).bit_length()&#x0a;6]]></desc>
		</keyword>
		<keyword name="bool" type="function" returnType="">
			<desc><![CDATA[bool(x) -&gt; bool&#x0a;&#x0a;Returns True when the argument x is true, False otherwise.&#x0a;The builtins True and False are the only two instances of the class bool.&#x0a;The class bool is a subclass of the class int, and cannot be subclassed.]]></desc>
		</keyword>
		<keyword name="break" type="other" definedIn="built-in" />
		<keyword name="buffer" type="function" returnType="">
			<desc><![CDATA[buffer(object [, offset[, size]])&#x0a;&#x0a;Create a new buffer object which references the given object.&#x0a;The buffer will reference a slice of the target object from the&#x0a;start of the object (or at the specified offset). The slice will&#x0a;extend to the end of the target object (or with the specified size).]]></desc>
		</keyword>
		<keyword name="bytearray" type="function" returnType="">
			<desc><![CDATA[bytearray(iterable_of_ints) -&gt; bytearray.&#x0a;bytearray(string, encoding[, errors]) -&gt; bytearray.&#x0a;bytearray(bytes_or_bytearray) -&gt; mutable copy of bytes_or_bytearray.&#x0a;bytearray(memory_view) -&gt; bytearray.&#x0a;&#x0a;Construct an mutable bytearray object from:&#x0a;  - an iterable yielding integers in range(256)&#x0a;  - a text string encoded using the specified encoding&#x0a;  - a bytes or a bytearray object&#x0a;  - any object implementing the buffer API.&#x0a;&#x0a;bytearray(int) -&gt; bytearray.&#x0a;&#x0a;Construct a zero-initialized bytearray of the given length.]]></desc>
		</keyword>
		<keyword name="bytes" type="function" returnType="">
			<desc><![CDATA[str(object) -&gt; string&#x0a;&#x0a;Return a nice string representation of the object.&#x0a;If the argument is a string, the return value is the same object.]]></desc>
		</keyword>
		<keyword name="callable" type="function" returnType="">
			<desc><![CDATA[callable(object) -&gt; bool&#x0a;&#x0a;Return whether the object is callable (i.e., some kind of function).&#x0a;Note that classes are callable, as are instances with a __call__() method.]]></desc>
		</keyword>
		<keyword name="capitalize" type="function" returnType="">
			<desc><![CDATA[S.capitalize() -&gt; string&#x0a;&#x0a;Return a copy of the string S with only its first character&#x0a;capitalized.]]></desc>
		</keyword>
		<keyword name="center" type="function" returnType="">
			<desc><![CDATA[B.center(width[, fillchar]) -&gt; copy of B&#x0a;&#x0a;Return B centered in a string of length width.  Padding is&#x0a;done using the specified fill character (default is a space).]]></desc>
		</keyword>
		<keyword name="chr" type="function" returnType="">
			<desc><![CDATA[chr(i) -&gt; character&#x0a;&#x0a;Return a string of one character with ordinal i; 0 &lt;= i &lt; 256.]]></desc>
		</keyword>
		<keyword name="class" type="other" definedIn="built-in" />
		<keyword name="classmethod" type="function" returnType="">
			<desc><![CDATA[classmethod(function) -&gt; method&#x0a;&#x0a;Convert a function to be a class method.&#x0a;&#x0a;A class method receives the class as implicit first argument,&#x0a;just like an instance method receives the instance.&#x0a;To declare a class method, use this idiom:&#x0a;&#x0a;  class C:&#x0a;      def f(cls, arg1, arg2, ...): ...&#x0a;      f = classmethod(f)&#x0a;&#x0a;It can be called either on the class (e.g. C.f()) or on an instance&#x0a;(e.g. C().f()).  The instance is ignored except for its class.&#x0a;If a class method is called for a derived class, the derived class&#x0a;object is passed as the implied first argument.&#x0a;&#x0a;Class methods are different than C++ or Java static methods.&#x0a;If you want those, see the staticmethod builtin.]]></desc>
		</keyword>
		<keyword name="clear" type="function" returnType="">
			<desc><![CDATA[Remove all elements from this set.]]></desc>
		</keyword>
		<keyword name="close" type="function" returnType="">
			<desc><![CDATA[close() -&gt; None or (perhaps) an integer.  Close the file.&#x0a;&#x0a;Sets data attribute .closed to True.  A closed file cannot be used for&#x0a;further I/O operations.  close() may be called more than once without&#x0a;error.  Some kinds of file objects (for example, opened by popen())&#x0a;may return an exit status upon closing.]]></desc>
		</keyword>
		<keyword name="cmp" type="function" returnType="">
			<desc><![CDATA[cmp(x, y) -&gt; integer&#x0a;&#x0a;Return negative if x&lt;y, zero if x==y, positive if x&gt;y.]]></desc>
		</keyword>
		<keyword name="coerce" type="function" returnType="">
			<desc><![CDATA[coerce(x, y) -&gt; (x1, y1)&#x0a;&#x0a;Return a tuple consisting of the two numeric arguments converted to&#x0a;a common type, using the same rules as used by arithmetic operations.&#x0a;If coercion is not possible, raise TypeError.]]></desc>
		</keyword>
		<keyword name="compile" type="function" returnType="">
			<desc><![CDATA[compile(source, filename, mode[, flags[, dont_inherit]]) -&gt; code object&#x0a;&#x0a;Compile the source string (a Python module, statement or expression)&#x0a;into a code object that can be executed by the exec statement or eval().&#x0a;The filename will be used for run-time error messages.&#x0a;The mode must be 'exec' to compile a module, 'single' to compile a&#x0a;single (interactive) statement, or 'eval' to compile an expression.&#x0a;The flags argument, if present, controls which future statements influence&#x0a;the compilation of the code.&#x0a;The dont_inherit argument, if non-zero, stops the compilation inheriting&#x0a;the effects of any future statements in effect in the code calling&#x0a;compile; if absent or zero these statements do influence the compilation,&#x0a;in addition to any features explicitly specified.]]></desc>
		</keyword>
		<keyword name="complex" type="function" returnType="">
			<desc><![CDATA[complex(real[, imag]) -&gt; complex number&#x0a;&#x0a;Create a complex number from a real part and an optional imaginary part.&#x0a;This is equivalent to (real + imag*1j) where imag defaults to 0.]]></desc>
		</keyword>
		<keyword name="conjugate" type="function" returnType="">
			<desc><![CDATA[Returns self, the complex conjugate of any int.]]></desc>
		</keyword>
		<keyword name="continue" type="other" definedIn="built-in" />
		<keyword name="copy" type="function" returnType="">
			<desc><![CDATA[D.copy() -&gt; a shallow copy of D]]></desc>
		</keyword>
		<keyword name="count" type="function" returnType="">
			<desc><![CDATA[L.count(value) -&gt; integer -- return number of occurrences of value]]></desc>
		</keyword>
		<keyword name="decode" type="function" returnType="">
			<desc><![CDATA[S.decode([encoding[,errors]]) -&gt; object&#x0a;&#x0a;Decodes S using the codec registered for encoding. encoding defaults&#x0a;to the default encoding. errors may be given to set a different error&#x0a;handling scheme. Default is 'strict' meaning that encoding errors raise&#x0a;a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'&#x0a;as well as any other name registered with codecs.register_error that is&#x0a;able to handle UnicodeDecodeErrors.]]></desc>
		</keyword>
		<keyword name="def" type="other" definedIn="built-in" />
		<keyword name="del" type="other" definedIn="built-in" />
		<keyword name="delattr" type="function" returnType="">
			<desc><![CDATA[delattr(object, name)&#x0a;&#x0a;Delete a named attribute on an object; delattr(x, 'y') is equivalent to&#x0a;``del x.y''.]]></desc>
		</keyword>
		<keyword name="deleter" type="function" returnType="">
			<desc><![CDATA[Descriptor to change the deleter on a property.]]></desc>
		</keyword>
		<keyword name="dict" type="function" returnType="">
			<desc><![CDATA[dict() -&gt; new empty dictionary&#x0a;dict(mapping) -&gt; new dictionary initialized from a mapping object's&#x0a;    (key, value) pairs&#x0a;dict(iterable) -&gt; new dictionary initialized as if via:&#x0a;    d = {}&#x0a;    for k, v in iterable:&#x0a;        d[k] = v&#x0a;dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs&#x0a;    in the keyword argument list.  For example:  dict(one=1, two=2)]]></desc>
		</keyword>
		<keyword name="difference" type="function" returnType="">
			<desc><![CDATA[Return the difference of two or more sets as a new set.&#x0a;&#x0a;(i.e. all elements that are in this set but not the others.)]]></desc>
		</keyword>
		<keyword name="difference_update" type="function" returnType="">
			<desc><![CDATA[Remove all elements of another set from this set.]]></desc>
		</keyword>
		<keyword name="dir" type="function" returnType="">
			<desc><![CDATA[dir([object]) -&gt; list of strings&#x0a;&#x0a;If called without an argument, return the names in the current scope.&#x0a;Else, return an alphabetized list of names comprising (some of) the attributes&#x0a;of the given object, and of attributes reachable from it.&#x0a;If the object supplies a method named __dir__, it will be used; otherwise&#x0a;the default dir() logic is used and returns:&#x0a;  for a module object: the module's attributes.&#x0a;  for a class object:  its attributes, and recursively the attributes&#x0a;    of its bases.&#x0a;  for any other object: its attributes, its class's attributes, and&#x0a;    recursively the attributes of its class's base classes.]]></desc>
		</keyword>
		<keyword name="discard" type="function" returnType="">
			<desc><![CDATA[Remove an element from a set if it is a member.&#x0a;&#x0a;If the element is not a member, do nothing.]]></desc>
		</keyword>
		<keyword name="divmod" type="function" returnType="">
			<desc><![CDATA[divmod(x, y) -&gt; (div, mod)&#x0a;&#x0a;Return the tuple ((x-x%y)/y, x%y).  Invariant: div*y + mod == x.]]></desc>
		</keyword>
		<keyword name="elif" type="other" definedIn="built-in" />
		<keyword name="else" type="other" definedIn="built-in" />
		<keyword name="encode" type="function" returnType="">
			<desc><![CDATA[S.encode([encoding[,errors]]) -&gt; string or unicode&#x0a;&#x0a;Encodes S using the codec registered for encoding. encoding defaults&#x0a;to the default encoding. errors may be given to set a different error&#x0a;handling scheme. Default is 'strict' meaning that encoding errors raise&#x0a;a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and&#x0a;'xmlcharrefreplace' as well as any other name registered with&#x0a;codecs.register_error that can handle UnicodeEncodeErrors.]]></desc>
		</keyword>
		<keyword name="endswith" type="function" returnType="">
			<desc><![CDATA[B.endswith(suffix [,start [,end]]) -&gt; bool&#x0a;&#x0a;Return True if B ends with the specified suffix, False otherwise.&#x0a;With optional start, test B beginning at that position.&#x0a;With optional end, stop comparing B at that position.&#x0a;suffix can also be a tuple of strings to try.]]></desc>
		</keyword>
		<keyword name="enumerate" type="function" returnType="">
			<desc><![CDATA[enumerate(iterable[, start]) -&gt; iterator for index, value of iterable&#x0a;&#x0a;Return an enumerate object.  iterable must be another object that supports&#x0a;iteration.  The enumerate object yields pairs containing a count (from&#x0a;start, which defaults to zero) and a value yielded by the iterable argument.&#x0a;enumerate is useful for obtaining an indexed list:&#x0a;    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...]]></desc>
		</keyword>
		<keyword name="eval" type="function" returnType="">
			<desc><![CDATA[eval(source[, globals[, locals]]) -&gt; value&#x0a;&#x0a;Evaluate the source in the context of globals and locals.&#x0a;The source may be a string representing a Python expression&#x0a;or a code object as returned by compile().&#x0a;The globals must be a dictionary and locals can be any mapping,&#x0a;defaulting to the current globals and locals.&#x0a;If only globals is given, locals defaults to it.]]></desc>
		</keyword>
		<keyword name="except" type="other" definedIn="built-in" />
		<keyword name="exec" type="other" definedIn="built-in" />
		<keyword name="execfile" type="function" returnType="">
			<desc><![CDATA[execfile(filename[, globals[, locals]])&#x0a;&#x0a;Read and execute a Python script from a file.&#x0a;The globals and locals are dictionaries, defaulting to the current&#x0a;globals and locals.  If only globals is given, locals defaults to it.]]></desc>
		</keyword>
		<keyword name="expandtabs" type="function" returnType="">
			<desc><![CDATA[B.expandtabs([tabsize]) -&gt; copy of B&#x0a;&#x0a;Return a copy of B where all tab characters are expanded using spaces.&#x0a;If tabsize is not given, a tab size of 8 characters is assumed.]]></desc>
		</keyword>
		<keyword name="extend" type="function" returnType="">
			<desc><![CDATA[B.extend(iterable int) -&gt; None&#x0a;&#x0a;Append all the elements from the iterator or sequence to the&#x0a;end of B.]]></desc>
		</keyword>
		<keyword name="file" type="function" returnType="">
			<desc><![CDATA[file(name[, mode[, buffering]]) -&gt; file object&#x0a;&#x0a;Open a file.  The mode can be 'r', 'w' or 'a' for reading (default),&#x0a;writing or appending.  The file will be created if it doesn't exist&#x0a;when opened for writing or appending; it will be truncated when&#x0a;opened for writing.  Add a 'b' to the mode for binary files.&#x0a;Add a '+' to the mode to allow simultaneous reading and writing.&#x0a;If the buffering argument is given, 0 means unbuffered, 1 means line&#x0a;buffered, and larger numbers specify the buffer size.  The preferred way&#x0a;to open a file is with the builtin open() function.&#x0a;Add a 'U' to mode to open the file for input with universal newline&#x0a;support.  Any line ending in the input file will be seen as a '\n'&#x0a;in Python.  Also, a file so opened gains the attribute 'newlines';&#x0a;the value for this attribute is one of None (no newline read yet),&#x0a;'\r', '\n', '\r\n' or a tuple containing all the newline types seen.&#x0a;&#x0a;'U' cannot be combined with 'w' or '+' mode.]]></desc>
		</keyword>
		<keyword name="fileno" type="function" returnType="">
			<desc>
				<![CDATA[fileno() -&gt; integer "file descriptor".&#x0a;&#x0a;This is needed for lower-level file interfaces, such os.read().]]>
			</desc>
		</keyword>
		<keyword name="filter" type="function" returnType="">
			<desc><![CDATA[filter(function or None, sequence) -&gt; list, tuple, or string&#x0a;&#x0a;Return those items of sequence for which function(item) is true.  If&#x0a;function is None, return the items that are true.  If sequence is a tuple&#x0a;or string, return the same type, else return a list.]]></desc>
		</keyword>
		<keyword name="finally" type="other" definedIn="built-in" />
		<keyword name="find" type="function" returnType="">
			<desc><![CDATA[S.find(sub [,start [,end]]) -&gt; int&#x0a;&#x0a;Return the lowest index in S where substring sub is found,&#x0a;such that sub is contained within s[start:end].  Optional&#x0a;arguments start and end are interpreted as in slice notation.&#x0a;&#x0a;Return -1 on failure.]]></desc>
		</keyword>
		<keyword name="float" type="function" returnType="">
			<desc><![CDATA[float(x) -&gt; floating point number&#x0a;&#x0a;Convert a string or number to a floating point number, if possible.]]></desc>
		</keyword>
		<keyword name="flush" type="function" returnType="">
			<desc><![CDATA[flush() -&gt; None.  Flush the internal I/O buffer.]]></desc>
		</keyword>
		<keyword name="for" type="other" definedIn="built-in" />
		<keyword name="format" type="function" returnType="">
			<desc><![CDATA[S.format(*args, **kwargs) -&gt; unicode]]></desc>
		</keyword>
		<keyword name="from" type="other" definedIn="built-in" />
		<keyword name="fromhex" type="function" returnType="">
			<desc><![CDATA[float.fromhex(string) -&gt; float&#x0a;&#x0a;Create a floating-point number from a hexadecimal string.&#x0a;&gt;&gt;&gt; float.fromhex('0x1.ffffp10')&#x0a;2047.984375&#x0a;&gt;&gt;&gt; float.fromhex('-0x1p-1074')&#x0a;-4.9406564584124654e-324]]></desc>
		</keyword>
		<keyword name="fromkeys" type="function" returnType="">
			<desc><![CDATA[dict.fromkeys(S[,v]) -&gt; New dict with keys from S and values equal to v.&#x0a;v defaults to None.]]></desc>
		</keyword>
		<keyword name="frozenset" type="function" returnType="">
			<desc><![CDATA[frozenset() -&gt; empty frozenset object&#x0a;frozenset(iterable) -&gt; frozenset object&#x0a;&#x0a;Build an immutable unordered collection of unique elements.]]></desc>
		</keyword>
		<keyword name="get" type="function" returnType="">
			<desc><![CDATA[D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.]]></desc>
		</keyword>
		<keyword name="getattr" type="function" returnType="">
			<desc><![CDATA[getattr(object, name[, default]) -&gt; value&#x0a;&#x0a;Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.&#x0a;When a default argument is given, it is returned when the attribute doesn't&#x0a;exist; without it, an exception is raised in that case.]]></desc>
		</keyword>
		<keyword name="getter" type="function" returnType="">
			<desc><![CDATA[Descriptor to change the getter on a property.]]></desc>
		</keyword>
		<keyword name="global" type="other" definedIn="built-in" />
		<keyword name="globals" type="function" returnType="">
			<desc><![CDATA[globals() -&gt; dictionary&#x0a;&#x0a;Return the dictionary containing the current scope's global variables.]]></desc>
		</keyword>
		<keyword name="has_key" type="function" returnType="">
			<desc><![CDATA[D.has_key(k) -&gt; True if D has a key k, else False]]></desc>
		</keyword>
		<keyword name="hasattr" type="function" returnType="">
			<desc><![CDATA[hasattr(object, name) -&gt; bool&#x0a;&#x0a;Return whether the object has an attribute with the given name.&#x0a;(This is done by calling getattr(object, name) and catching exceptions.)]]></desc>
		</keyword>
		<keyword name="hash" type="function" returnType="">
			<desc><![CDATA[hash(object) -&gt; integer&#x0a;&#x0a;Return a hash value for the object.  Two objects with the same value have&#x0a;the same hash value.  The reverse is not necessarily true, but likely.]]></desc>
		</keyword>
		<keyword name="hex" type="function" returnType="">
			<desc><![CDATA[float.hex() -&gt; string&#x0a;&#x0a;Return a hexadecimal representation of a floating-point number.&#x0a;&gt;&gt;&gt; (-0.1).hex()&#x0a;'-0x1.999999999999ap-4'&#x0a;&gt;&gt;&gt; 3.14159.hex()&#x0a;'0x1.921f9f01b866ep+1']]></desc>
		</keyword>
		<keyword name="id" type="function" returnType="">
			<desc><![CDATA[id(object) -&gt; integer&#x0a;&#x0a;Return the identity of an object.  This is guaranteed to be unique among&#x0a;simultaneously existing objects.  (Hint: it's the object's memory address.)]]></desc>
		</keyword>
		<keyword name="if" type="other" definedIn="built-in" />
		<keyword name="import" type="other" definedIn="built-in" />
		<keyword name="in" type="other" definedIn="built-in" />
		<keyword name="index" type="function" returnType="">
			<desc><![CDATA[S.index(sub [,start [,end]]) -&gt; int&#x0a;&#x0a;Like S.find() but raise ValueError when the substring is not found.]]></desc>
		</keyword>
		<keyword name="indices" type="function" returnType="">
			<desc><![CDATA[S.indices(len) -&gt; (start, stop, stride)&#x0a;&#x0a;Assuming a sequence of length len, calculate the start and stop&#x0a;indices, and the stride length of the extended slice described by&#x0a;S. Out of bounds indices are clipped in a manner consistent with the&#x0a;handling of normal slices.]]></desc>
		</keyword>
		<keyword name="input" type="function" returnType="">
			<desc><![CDATA[input([prompt]) -&gt; value&#x0a;&#x0a;Equivalent to eval(raw_input(prompt)).]]></desc>
		</keyword>
		<keyword name="insert" type="function" returnType="">
			<desc><![CDATA[B.insert(index, int) -&gt; None&#x0a;&#x0a;Insert a single item into the bytearray before the given index.]]></desc>
		</keyword>
		<keyword name="int" type="function" returnType="">
			<desc><![CDATA[int(x[, base]) -&gt; integer&#x0a;&#x0a;Convert a string or number to an integer, if possible.  A floating point&#x0a;argument will be truncated towards zero (this does not include a string&#x0a;representation of a floating point number!)  When converting a string, use&#x0a;the optional base.  It is an error to supply a base when converting a&#x0a;non-string.  If base is zero, the proper base is guessed based on the&#x0a;string content.  If the argument is outside the integer range a&#x0a;long object will be returned instead.]]></desc>
		</keyword>
		<keyword name="intern" type="function" returnType="">
			<desc><![CDATA[intern(string) -&gt; string&#x0a;&#x0a;``Intern'' the given string.  This enters the string in the (global)&#x0a;table of interned strings whose purpose is to speed up dictionary lookups.&#x0a;Return the string itself or the previously interned string object with the&#x0a;same value.]]></desc>
		</keyword>
		<keyword name="intersection" type="function" returnType="">
			<desc><![CDATA[Return the intersection of two or more sets as a new set.&#x0a;&#x0a;(i.e. elements that are common to all of the sets.)]]></desc>
		</keyword>
		<keyword name="intersection_update" type="function"
			returnType="">
			<desc><![CDATA[Update a set with the intersection of itself and another.]]></desc>
		</keyword>
		<keyword name="is" type="other" definedIn="built-in" />
		<keyword name="is_integer" type="function" returnType="">
			<desc><![CDATA[Returns True if the float is an integer.]]></desc>
		</keyword>
		<keyword name="isalnum" type="function" returnType="">
			<desc><![CDATA[S.isalnum() -&gt; bool&#x0a;&#x0a;Return True if all characters in S are alphanumeric&#x0a;and there is at least one character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="isalpha" type="function" returnType="">
			<desc><![CDATA[S.isalpha() -&gt; bool&#x0a;&#x0a;Return True if all characters in S are alphabetic&#x0a;and there is at least one character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="isatty" type="function" returnType="">
			<desc><![CDATA[isatty() -&gt; true or false.  True if the file is connected to a tty device.]]></desc>
		</keyword>
		<keyword name="isdecimal" type="function" returnType="">
			<desc><![CDATA[S.isdecimal() -&gt; bool&#x0a;&#x0a;Return True if there are only decimal characters in S,&#x0a;False otherwise.]]></desc>
		</keyword>
		<keyword name="isdigit" type="function" returnType="">
			<desc><![CDATA[S.isdigit() -&gt; bool&#x0a;&#x0a;Return True if all characters in S are digits&#x0a;and there is at least one character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="isdisjoint" type="function" returnType="">
			<desc><![CDATA[Return True if two sets have a null intersection.]]></desc>
		</keyword>
		<keyword name="isinstance" type="function" returnType="">
			<desc><![CDATA[isinstance(object, class-or-type-or-tuple) -&gt; bool&#x0a;&#x0a;Return whether an object is an instance of a class or of a subclass thereof.&#x0a;With a type as second argument, return whether that is the object's type.&#x0a;The form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for&#x0a;isinstance(x, A) or isinstance(x, B) or ... (etc.).]]></desc>
		</keyword>
		<keyword name="islower" type="function" returnType="">
			<desc><![CDATA[S.islower() -&gt; bool&#x0a;&#x0a;Return True if all cased characters in S are lowercase and there is&#x0a;at least one cased character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="isnumeric" type="function" returnType="">
			<desc><![CDATA[S.isnumeric() -&gt; bool&#x0a;&#x0a;Return True if there are only numeric characters in S,&#x0a;False otherwise.]]></desc>
		</keyword>
		<keyword name="isspace" type="function" returnType="">
			<desc><![CDATA[S.isspace() -&gt; bool&#x0a;&#x0a;Return True if all characters in S are whitespace&#x0a;and there is at least one character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="issubclass" type="function" returnType="">
			<desc><![CDATA[issubclass(C, B) -&gt; bool&#x0a;&#x0a;Return whether class C is a subclass (i.e., a derived class) of class B.&#x0a;When using a tuple as the second argument issubclass(X, (A, B, ...)),&#x0a;is a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).]]></desc>
		</keyword>
		<keyword name="issubset" type="function" returnType="">
			<desc><![CDATA[Report whether another set contains this set.]]></desc>
		</keyword>
		<keyword name="issuperset" type="function" returnType="">
			<desc><![CDATA[Report whether this set contains another set.]]></desc>
		</keyword>
		<keyword name="istitle" type="function" returnType="">
			<desc><![CDATA[S.istitle() -&gt; bool&#x0a;&#x0a;Return True if S is a titlecased string and there is at least one&#x0a;character in S, i.e. uppercase characters may only follow uncased&#x0a;characters and lowercase characters only cased ones. Return False&#x0a;otherwise.]]></desc>
		</keyword>
		<keyword name="isupper" type="function" returnType="">
			<desc><![CDATA[S.isupper() -&gt; bool&#x0a;&#x0a;Return True if all cased characters in S are uppercase and there is&#x0a;at least one cased character in S, False otherwise.]]></desc>
		</keyword>
		<keyword name="items" type="function" returnType="">
			<desc><![CDATA[D.items() -&gt; list of D's (key, value) pairs, as 2-tuples]]></desc>
		</keyword>
		<keyword name="iter" type="function" returnType="">
			<desc><![CDATA[iter(collection) -&gt; iterator&#x0a;iter(callable, sentinel) -&gt; iterator&#x0a;&#x0a;Get an iterator from an object.  In the first form, the argument must&#x0a;supply its own iterator, or be a sequence.&#x0a;In the second form, the callable is called until it returns the sentinel.]]></desc>
		</keyword>
		<keyword name="iteritems" type="function" returnType="">
			<desc><![CDATA[D.iteritems() -&gt; an iterator over the (key, value) items of D]]></desc>
		</keyword>
		<keyword name="iterkeys" type="function" returnType="">
			<desc><![CDATA[D.iterkeys() -&gt; an iterator over the keys of D]]></desc>
		</keyword>
		<keyword name="itervalues" type="function" returnType="">
			<desc><![CDATA[D.itervalues() -&gt; an iterator over the values of D]]></desc>
		</keyword>
		<keyword name="join" type="function" returnType="">
			<desc><![CDATA[S.join(iterable) -&gt; unicode&#x0a;&#x0a;Return a string which is the concatenation of the strings in the&#x0a;iterable.  The separator between elements is S.]]></desc>
		</keyword>
		<keyword name="keys" type="function" returnType="">
			<desc><![CDATA[D.keys() -&gt; list of D's keys]]></desc>
		</keyword>
		<keyword name="lambda" type="other" definedIn="built-in" />
		<keyword name="len" type="function" returnType="">
			<desc><![CDATA[len(object) -&gt; integer&#x0a;&#x0a;Return the number of items of a sequence or mapping.]]></desc>
		</keyword>
		<keyword name="list" type="function" returnType="">
			<desc><![CDATA[list() -&gt; new empty list&#x0a;list(iterable) -&gt; new list initialized from iterable's items]]></desc>
		</keyword>
		<keyword name="ljust" type="function" returnType="">
			<desc><![CDATA[S.ljust(width[, fillchar]) -&gt; string&#x0a;&#x0a;Return S left-justified in a string of length width. Padding is&#x0a;done using the specified fill character (default is a space).]]></desc>
		</keyword>
		<keyword name="locals" type="function" returnType="">
			<desc><![CDATA[locals() -&gt; dictionary&#x0a;&#x0a;Update and return a dictionary containing the current scope's local variables.]]></desc>
		</keyword>
		<keyword name="long" type="function" returnType="">
			<desc><![CDATA[long(x[, base]) -&gt; integer&#x0a;&#x0a;Convert a string or number to a long integer, if possible.  A floating&#x0a;point argument will be truncated towards zero (this does not include a&#x0a;string representation of a floating point number!)  When converting a&#x0a;string, use the optional base.  It is an error to supply a base when&#x0a;converting a non-string.]]></desc>
		</keyword>
		<keyword name="lower" type="function" returnType="">
			<desc><![CDATA[S.lower() -&gt; string&#x0a;&#x0a;Return a copy of the string S converted to lowercase.]]></desc>
		</keyword>
		<keyword name="lstrip" type="function" returnType="">
			<desc><![CDATA[S.lstrip([chars]) -&gt; string or unicode&#x0a;&#x0a;Return a copy of the string S with leading whitespace removed.&#x0a;If chars is given and not None, remove characters in chars instead.&#x0a;If chars is unicode, S will be converted to unicode before stripping]]></desc>
		</keyword>
		<keyword name="map" type="function" returnType="">
			<desc><![CDATA[map(function, sequence[, sequence, ...]) -&gt; list&#x0a;&#x0a;Return a list of the results of applying the function to the items of&#x0a;the argument sequence(s).  If more than one sequence is given, the&#x0a;function is called with an argument list consisting of the corresponding&#x0a;item of each sequence, substituting None for missing values when not all&#x0a;sequences have the same length.  If the function is None, return a list of&#x0a;the items of the sequence (or a list of tuples if more than one sequence).]]></desc>
		</keyword>
		<keyword name="max" type="function" returnType="">
			<desc><![CDATA[max(iterable[, key=func]) -&gt; value&#x0a;max(a, b, c, ...[, key=func]) -&gt; value&#x0a;&#x0a;With a single iterable argument, return its largest item.&#x0a;With two or more arguments, return the largest argument.]]></desc>
		</keyword>
		<keyword name="memoryview" type="function" returnType="">
			<desc><![CDATA[memoryview(object)&#x0a;&#x0a;Create a new memoryview object which references the given object.]]></desc>
		</keyword>
		<keyword name="min" type="function" returnType="">
			<desc><![CDATA[min(iterable[, key=func]) -&gt; value&#x0a;min(a, b, c, ...[, key=func]) -&gt; value&#x0a;&#x0a;With a single iterable argument, return its smallest item.&#x0a;With two or more arguments, return the smallest argument.]]></desc>
		</keyword>
		<keyword name="mro" type="function" returnType="">
			<desc><![CDATA[mro() -&gt; list&#x0a;return a type's method resolution order]]></desc>
		</keyword>
		<keyword name="next" type="function" returnType="">
			<desc><![CDATA[x.next() -&gt; the next value, or raise StopIteration]]></desc>
		</keyword>
		<keyword name="not" type="other" definedIn="built-in" />
		<keyword name="object" type="function" returnType="">
			<desc><![CDATA[The most base type]]></desc>
		</keyword>
		<keyword name="oct" type="function" returnType="">
			<desc><![CDATA[oct(number) -&gt; string&#x0a;&#x0a;Return the octal representation of an integer or long integer.]]></desc>
		</keyword>
		<keyword name="open" type="function" returnType="">
			<desc><![CDATA[open(name[, mode[, buffering]]) -&gt; file object&#x0a;&#x0a;Open a file using the file() type, returns a file object.  This is the&#x0a;preferred way to open a file.  See file.__doc__ for further information.]]></desc>
		</keyword>
		<keyword name="or" type="other" definedIn="built-in" />
		<keyword name="ord" type="function" returnType="">
			<desc><![CDATA[ord(c) -&gt; integer&#x0a;&#x0a;Return the integer ordinal of a one-character string.]]></desc>
		</keyword>
		<keyword name="partition" type="function" returnType="">
			<desc><![CDATA[S.partition(sep) -&gt; (head, sep, tail)&#x0a;&#x0a;Search for the separator sep in S, and return the part before it,&#x0a;the separator itself, and the part after it.  If the separator is not&#x0a;found, return S and two empty strings.]]></desc>
		</keyword>
		<keyword name="pass" type="other" definedIn="built-in" />
		<keyword name="pop" type="function" returnType="">
			<desc><![CDATA[L.pop([index]) -&gt; item -- remove and return item at index (default last).&#x0a;Raises IndexError if list is empty or index is out of range.]]></desc>
		</keyword>
		<keyword name="popitem" type="function" returnType="">
			<desc><![CDATA[D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a&#x0a;2-tuple; but raise KeyError if D is empty.]]></desc>
		</keyword>
		<keyword name="pow" type="function" returnType="">
			<desc><![CDATA[pow(x, y[, z]) -&gt; number&#x0a;&#x0a;With two arguments, equivalent to x**y.  With three arguments,&#x0a;equivalent to (x**y) % z, but may be more efficient (e.g. for longs).]]></desc>
		</keyword>
		<keyword name="print" type="other" definedIn="built-in" />
		<keyword name="property" type="function" returnType="">
			<desc><![CDATA[property(fget=None, fset=None, fdel=None, doc=None) -&gt; property attribute&#x0a;&#x0a;fget is a function to be used for getting an attribute value, and likewise&#x0a;fset is a function for setting, and fdel a function for del'ing, an&#x0a;attribute.  Typical use is to define a managed attribute x:&#x0a;class C(object):&#x0a;    def getx(self): return self._x&#x0a;    def setx(self, value): self._x = value&#x0a;    def delx(self): del self._x&#x0a;    x = property(getx, setx, delx, &quot;I'm the 'x' property.&quot;)&#x0a;&#x0a;Decorators make defining new properties or modifying existing ones easy:&#x0a;class C(object):&#x0a;    @property&#x0a;    def x(self): return self._x&#x0a;    @x.setter&#x0a;    def x(self, value): self._x = value&#x0a;    @x.deleter&#x0a;    def x(self): del self._x]]></desc>
		</keyword>
		<keyword name="raise" type="other" definedIn="built-in" />
		<keyword name="range" type="function" returnType="Object[]">
			<desc><![CDATA[range([start,] stop[, step]) -&gt; list of integers&#x0a;&#x0a;Return a list containing an arithmetic progression of integers.&#x0a;range(i, j) returns [i, i+1, i+2, ..., j-1]; start (!) defaults to 0.&#x0a;When step is given, it specifies the increment (or decrement).&#x0a;For example, range(4) returns [0, 1, 2, 3].  The end point is omitted!&#x0a;These are exactly the valid indices for a list of 4 elements.]]></desc>
		</keyword>
		<keyword name="raw_input" type="function" returnType="">
			<desc><![CDATA[raw_input([prompt]) -&gt; string&#x0a;&#x0a;Read a string from standard input.  The trailing newline is stripped.&#x0a;If the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.&#x0a;On Unix, GNU readline is used if enabled.  The prompt string, if given,&#x0a;is printed without a trailing newline before reading.]]></desc>
		</keyword>
		<keyword name="read" type="function" returnType="">
			<desc><![CDATA[read([size]) -&gt; read at most size bytes, returned as a string.&#x0a;&#x0a;If the size argument is negative or omitted, read until EOF is reached.&#x0a;Notice that when in non-blocking mode, less data than what was requested&#x0a;may be returned, even if no size parameter was given.]]></desc>
		</keyword>
		<keyword name="readinto" type="function" returnType="">
			<desc><![CDATA[readinto() -&gt; Undocumented.  Don't use this; it may go away.]]></desc>
		</keyword>
		<keyword name="readline" type="function" returnType="">
			<desc><![CDATA[readline([size]) -&gt; next line from the file, as a string.&#x0a;&#x0a;Retain newline.  A non-negative size argument limits the maximum&#x0a;number of bytes to return (an incomplete line may be returned then).&#x0a;Return an empty string at EOF.]]></desc>
		</keyword>
		<keyword name="readlines" type="function" returnType="">
			<desc><![CDATA[readlines([size]) -&gt; list of strings, each a line from the file.&#x0a;&#x0a;Call readline() repeatedly and return a list of the lines so read.&#x0a;The optional size argument, if given, is an approximate bound on the&#x0a;total number of bytes in the lines returned.]]></desc>
		</keyword>
		<keyword name="reduce" type="function" returnType="">
			<desc><![CDATA[reduce(function, sequence[, initial]) -&gt; value&#x0a;&#x0a;Apply a function of two arguments cumulatively to the items of a sequence,&#x0a;from left to right, so as to reduce the sequence to a single value.&#x0a;For example, reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates&#x0a;((((1+2)+3)+4)+5).  If initial is present, it is placed before the items&#x0a;of the sequence in the calculation, and serves as a default when the&#x0a;sequence is empty.]]></desc>
		</keyword>
		<keyword name="reload" type="function" returnType="">
			<desc><![CDATA[reload(module) -&gt; module&#x0a;&#x0a;Reload the module.  The module must have been successfully imported before.]]></desc>
		</keyword>
		<keyword name="remove" type="function" returnType="">
			<desc><![CDATA[Remove an element from a set; it must be a member.&#x0a;&#x0a;If the element is not a member, raise a KeyError.]]></desc>
		</keyword>
		<keyword name="replace" type="function" returnType="">
			<desc><![CDATA[B.replace(old, new[, count]) -&gt; bytes&#x0a;&#x0a;Return a copy of B with all occurrences of subsection&#x0a;old replaced by new.  If the optional argument count is&#x0a;given, only the first count occurrences are replaced.]]></desc>
		</keyword>
		<keyword name="repr" type="function" returnType="">
			<desc><![CDATA[repr(object) -&gt; string&#x0a;&#x0a;Return the canonical string representation of the object.&#x0a;For most object types, eval(repr(object)) == object.]]></desc>
		</keyword>
		<keyword name="return" type="other" definedIn="built-in" />
		<keyword name="reverse" type="function" returnType="">
			<desc><![CDATA[L.reverse() -- reverse *IN PLACE*]]></desc>
		</keyword>
		<keyword name="reversed" type="function" returnType="">
			<desc><![CDATA[reversed(sequence) -&gt; reverse iterator over values of the sequence&#x0a;&#x0a;Return a reverse iterator]]></desc>
		</keyword>
		<keyword name="rfind" type="function" returnType="">
			<desc><![CDATA[B.rfind(sub [,start [,end]]) -&gt; int&#x0a;&#x0a;Return the highest index in B where subsection sub is found,&#x0a;such that sub is contained within s[start,end].  Optional&#x0a;arguments start and end are interpreted as in slice notation.&#x0a;&#x0a;Return -1 on failure.]]></desc>
		</keyword>
		<keyword name="rindex" type="function" returnType="">
			<desc><![CDATA[S.rindex(sub [,start [,end]]) -&gt; int&#x0a;&#x0a;Like S.rfind() but raise ValueError when the substring is not found.]]></desc>
		</keyword>
		<keyword name="rjust" type="function" returnType="">
			<desc><![CDATA[B.rjust(width[, fillchar]) -&gt; copy of B&#x0a;&#x0a;Return B right justified in a string of length width. Padding is&#x0a;done using the specified fill character (default is a space)]]></desc>
		</keyword>
		<keyword name="round" type="function" returnType="">
			<desc><![CDATA[round(number[, ndigits]) -&gt; floating point number&#x0a;&#x0a;Round a number to a given precision in decimal digits (default 0 digits).&#x0a;This always returns a floating point number.  Precision may be negative.]]></desc>
		</keyword>
		<keyword name="rpartition" type="function" returnType="">
			<desc><![CDATA[B.rpartition(sep) -&gt; (head, sep, tail)&#x0a;&#x0a;Searches for the separator sep in B, starting at the end of B,&#x0a;and returns the part before it, the separator itself, and the&#x0a;part after it.  If the separator is not found, returns two empty&#x0a;bytearray objects and B.]]></desc>
		</keyword>
		<keyword name="rsplit" type="function" returnType="">
			<desc><![CDATA[S.rsplit([sep [,maxsplit]]) -&gt; list of strings&#x0a;&#x0a;Return a list of the words in the string S, using sep as the&#x0a;delimiter string, starting at the end of the string and working&#x0a;to the front.  If maxsplit is given, at most maxsplit splits are&#x0a;done. If sep is not specified or is None, any whitespace string&#x0a;is a separator.]]></desc>
		</keyword>
		<keyword name="rstrip" type="function" returnType="">
			<desc><![CDATA[S.rstrip([chars]) -&gt; string or unicode&#x0a;&#x0a;Return a copy of the string S with trailing whitespace removed.&#x0a;If chars is given and not None, remove characters in chars instead.&#x0a;If chars is unicode, S will be converted to unicode before stripping]]></desc>
		</keyword>
		<keyword name="seek" type="function" returnType="">
			<desc><![CDATA[seek(offset[, whence]) -&gt; None.  Move to new file position.&#x0a;&#x0a;Argument offset is a byte count.  Optional argument whence defaults to&#x0a;0 (offset from start of file, offset should be &gt;= 0); other values are 1&#x0a;(move relative to current position, positive or negative), and 2 (move&#x0a;relative to end of file, usually negative, although many platforms allow&#x0a;seeking beyond the end of a file).  If the file is opened in text mode,&#x0a;only offsets returned by tell() are legal.  Use of other offsets causes&#x0a;undefined behavior.&#x0a;Note that not all file objects are seekable.]]></desc>
		</keyword>
		<keyword name="set" type="function" returnType="">
			<desc><![CDATA[set() -&gt; new empty set object&#x0a;set(iterable) -&gt; new set object&#x0a;&#x0a;Build an unordered collection of unique elements.]]></desc>
		</keyword>
		<keyword name="setattr" type="function" returnType="">
			<desc><![CDATA[setattr(object, name, value)&#x0a;&#x0a;Set a named attribute on an object; setattr(x, 'y', v) is equivalent to&#x0a;``x.y = v''.]]></desc>
		</keyword>
		<keyword name="setdefault" type="function" returnType="">
			<desc><![CDATA[D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D]]></desc>
		</keyword>
		<keyword name="setter" type="function" returnType="">
			<desc><![CDATA[Descriptor to change the setter on a property.]]></desc>
		</keyword>
		<keyword name="slice" type="function" returnType="">
			<desc><![CDATA[slice([start,] stop[, step])&#x0a;&#x0a;Create a slice object.  This is used for extended slicing (e.g. a[0:10:2]).]]></desc>
		</keyword>
		<keyword name="sort" type="function" returnType="">
			<desc><![CDATA[L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;&#x0a;cmp(x, y) -&gt; -1, 0, 1]]></desc>
		</keyword>
		<keyword name="sorted" type="function" returnType="">
			<desc><![CDATA[sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list]]></desc>
		</keyword>
		<keyword name="split" type="function" returnType="">
			<desc><![CDATA[B.split([sep[, maxsplit]]) -&gt; list of bytearray&#x0a;&#x0a;Return a list of the sections in B, using sep as the delimiter.&#x0a;If sep is not given, B is split on ASCII whitespace characters&#x0a;(space, tab, return, newline, formfeed, vertical tab).&#x0a;If maxsplit is given, at most maxsplit splits are done.]]></desc>
		</keyword>
		<keyword name="splitlines" type="function" returnType="">
			<desc><![CDATA[S.splitlines([keepends]) -&gt; list of strings&#x0a;&#x0a;Return a list of the lines in S, breaking at line boundaries.&#x0a;Line breaks are not included in the resulting list unless keepends&#x0a;is given and true.]]></desc>
		</keyword>
		<keyword name="startswith" type="function" returnType="">
			<desc><![CDATA[S.startswith(prefix[, start[, end]]) -&gt; bool&#x0a;&#x0a;Return True if S starts with the specified prefix, False otherwise.&#x0a;With optional start, test S beginning at that position.&#x0a;With optional end, stop comparing S at that position.&#x0a;prefix can also be a tuple of strings to try.]]></desc>
		</keyword>
		<keyword name="staticmethod" type="function" returnType="">
			<desc><![CDATA[staticmethod(function) -&gt; method&#x0a;&#x0a;Convert a function to be a static method.&#x0a;&#x0a;A static method does not receive an implicit first argument.&#x0a;To declare a static method, use this idiom:&#x0a;&#x0a;     class C:&#x0a;     def f(arg1, arg2, ...): ...&#x0a;     f = staticmethod(f)&#x0a;&#x0a;It can be called either on the class (e.g. C.f()) or on an instance&#x0a;(e.g. C().f()).  The instance is ignored except for its class.&#x0a;&#x0a;Static methods in Python are similar to those found in Java or C++.&#x0a;For a more advanced concept, see the classmethod builtin.]]></desc>
		</keyword>
		<keyword name="str" type="function" returnType="">
			<desc><![CDATA[str(object) -&gt; string&#x0a;&#x0a;Return a nice string representation of the object.&#x0a;If the argument is a string, the return value is the same object.]]></desc>
		</keyword>
		<keyword name="strip" type="function" returnType="">
			<desc><![CDATA[S.strip([chars]) -&gt; string or unicode&#x0a;&#x0a;Return a copy of the string S with leading and trailing&#x0a;whitespace removed.&#x0a;If chars is given and not None, remove characters in chars instead.&#x0a;If chars is unicode, S will be converted to unicode before stripping]]></desc>
		</keyword>
		<keyword name="sum" type="function" returnType="">
			<desc><![CDATA[sum(sequence[, start]) -&gt; value&#x0a;&#x0a;Returns the sum of a sequence of numbers (NOT strings) plus the value&#x0a;of parameter 'start' (which defaults to 0).  When the sequence is&#x0a;empty, returns start.]]></desc>
		</keyword>
		<keyword name="super" type="function" returnType="">
			<desc><![CDATA[super(type) -&gt; unbound super object&#x0a;super(type, obj) -&gt; bound super object; requires isinstance(obj, type)&#x0a;super(type, type2) -&gt; bound super object; requires issubclass(type2, type)&#x0a;Typical use to call a cooperative superclass method:&#x0a;class C(B):&#x0a;    def meth(self, arg):&#x0a;        super(C, self).meth(arg)]]></desc>
		</keyword>
		<keyword name="swapcase" type="function" returnType="">
			<desc><![CDATA[S.swapcase() -&gt; string&#x0a;&#x0a;Return a copy of the string S with uppercase characters&#x0a;converted to lowercase and vice versa.]]></desc>
		</keyword>
		<keyword name="symmetric_difference" type="function"
			returnType="">
			<desc><![CDATA[Return the symmetric difference of two sets as a new set.&#x0a;&#x0a;(i.e. all elements that are in exactly one of the sets.)]]></desc>
		</keyword>
		<keyword name="symmetric_difference_update" type="function"
			returnType="">
			<desc><![CDATA[Update a set with the symmetric difference of itself and another.]]></desc>
		</keyword>
		<keyword name="tell" type="function" returnType="">
			<desc><![CDATA[tell() -&gt; current file position, an integer (may be a long integer).]]></desc>
		</keyword>
		<keyword name="title" type="function" returnType="">
			<desc><![CDATA[S.title() -&gt; unicode&#x0a;&#x0a;Return a titlecased version of S, i.e. words start with title case&#x0a;characters, all remaining cased characters have lower case.]]></desc>
		</keyword>
		<keyword name="tobytes" type="other" definedIn="built-in" />
		<keyword name="tolist" type="other" definedIn="built-in" />
		<keyword name="translate" type="function" returnType="">
			<desc><![CDATA[B.translate(table[, deletechars]) -&gt; bytearray&#x0a;&#x0a;Return a copy of B, where all characters occurring in the&#x0a;optional argument deletechars are removed, and the remaining&#x0a;characters have been mapped through the given translation&#x0a;table, which must be a bytes object of length 256.]]></desc>
		</keyword>
		<keyword name="truncate" type="function" returnType="">
			<desc><![CDATA[truncate([size]) -&gt; None.  Truncate the file to at most size bytes.&#x0a;&#x0a;Size defaults to the current file position, as returned by tell().]]></desc>
		</keyword>
		<keyword name="try" type="other" definedIn="built-in" />
		<keyword name="tuple" type="function" returnType="">
			<desc><![CDATA[tuple() -&gt; empty tuple&#x0a;tuple(iterable) -&gt; tuple initialized from iterable's items&#x0a;&#x0a;If the argument is a tuple, the return value is the same object.]]></desc>
		</keyword>
		<keyword name="type" type="function" returnType="">
			<desc><![CDATA[type(object) -&gt; the object's type&#x0a;type(name, bases, dict) -&gt; a new type]]></desc>
		</keyword>
		<keyword name="unichr" type="function" returnType="">
			<desc><![CDATA[unichr(i) -&gt; Unicode character&#x0a;&#x0a;Return a Unicode string of one character with ordinal i; 0 &lt;= i &lt;= 0x10ffff.]]></desc>
		</keyword>
		<keyword name="unicode" type="function" returnType="">
			<desc><![CDATA[unicode(string [, encoding[, errors]]) -&gt; object&#x0a;&#x0a;Create a new Unicode object from the given encoded string.&#x0a;encoding defaults to the current default string encoding.&#x0a;errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'.]]></desc>
		</keyword>
		<keyword name="union" type="function" returnType="">
			<desc><![CDATA[Return the union of sets as a new set.&#x0a;&#x0a;(i.e. all elements that are in either set.)]]></desc>
		</keyword>
		<keyword name="update" type="function" returnType="">
			<desc><![CDATA[D.update(E, **F) -&gt; None.  Update D from dict/iterable E and F.&#x0a;If E has a .keys() method, does:     for k in E: D[k] = E[k]&#x0a;If E lacks .keys() method, does:     for (k, v) in E: D[k] = v&#x0a;In either case, this is followed by: for k in F: D[k] = F[k]]]></desc>
		</keyword>
		<keyword name="upper" type="function" returnType="">
			<desc><![CDATA[S.upper() -&gt; unicode&#x0a;&#x0a;Return a copy of S converted to uppercase.]]></desc>
		</keyword>
		<keyword name="values" type="function" returnType="">
			<desc><![CDATA[D.values() -&gt; list of D's values]]></desc>
		</keyword>
		<keyword name="vars" type="function" returnType="">
			<desc><![CDATA[vars([object]) -&gt; dictionary&#x0a;&#x0a;Without arguments, equivalent to locals().&#x0a;With an argument, equivalent to object.__dict__.]]></desc>
		</keyword>
		<keyword name="viewitems" type="function" returnType="">
			<desc><![CDATA[D.viewitems() -&gt; a set-like object providing a view on D's items]]></desc>
		</keyword>
		<keyword name="viewkeys" type="function" returnType="">
			<desc><![CDATA[D.viewkeys() -&gt; a set-like object providing a view on D's keys]]></desc>
		</keyword>
		<keyword name="viewvalues" type="function" returnType="">
			<desc><![CDATA[D.viewvalues() -&gt; an object providing a view on D's values]]></desc>
		</keyword>
		<keyword name="while" type="other" definedIn="built-in" />
		<keyword name="with" type="other" definedIn="built-in" />
		<keyword name="write" type="function" returnType="">
			<desc><![CDATA[write(str) -&gt; None.  Write string str to file.&#x0a;&#x0a;Note that due to buffering, flush() or close() may be needed before&#x0a;the file on disk reflects the data written.]]></desc>
		</keyword>
		<keyword name="writelines" type="function" returnType="">
			<desc><![CDATA[writelines(sequence_of_strings) -&gt; None.  Write the strings to the file.&#x0a;&#x0a;Note that newlines are not added.  The sequence can be any iterable object&#x0a;producing strings. This is equivalent to calling write() for each string.]]></desc>
		</keyword>
		<keyword name="xrange" type="function" returnType="">
			<desc><![CDATA[xrange([start,] stop[, step]) -&gt; xrange object&#x0a;&#x0a;Like range(), but instead of returning a list, returns an object that&#x0a;generates the numbers in the range on demand.  For looping, this is &#x0a;slightly faster than range() and more memory efficient.]]></desc>
		</keyword>
		<keyword name="xreadlines" type="function" returnType="">
			<desc><![CDATA[xreadlines() -&gt; returns self.&#x0a;&#x0a;For backward compatibility. File objects now include the performance&#x0a;optimizations previously implemented in the xreadlines module.]]></desc>
		</keyword>
		<keyword name="yield" type="other" definedIn="built-in" />
		<keyword name="zfill" type="function" returnType="">
			<desc><![CDATA[B.zfill(width) -&gt; copy of B&#x0a;&#x0a;Pad a numeric string B with zeros on the left, to fill a field&#x0a;of the specified width.  B is never truncated.]]></desc>
		</keyword>
		<keyword name="zip" type="function" returnType="">
			<desc><![CDATA[zip(seq1 [, seq2 [...]]) -&gt; [(seq1[0], seq2[0] ...), (...)]&#x0a;&#x0a;Return a list of tuples, where each tuple contains the i-th element&#x0a;from each of the argument sequences.  The returned list is truncated&#x0a;in length to the length of the shortest argument sequence.]]></desc>
		</keyword>
	</keywords>
</api>